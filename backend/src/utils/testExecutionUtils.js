/*
 * File Path: backend/src/utils/testExecutionUtils.js
 * Purpose: Executes Playwright tests for tasks in Allur Space Console.
 * How It Works:
 *   - Runs tests generated by testUtils.js in headless or headed mode using taskTesterV18.js.
 *   - Validates test files and taskId, logs execution results to MongoDB Log model.
 * Mechanics:
 *   - Supports automated headless tests during task processing and manual headed tests via /grok/test.
 *   - Ensures test execution is isolated from test generation for modularity.
 * Dependencies:
 *   - taskTesterV18.js: Executes Playwright tests.
 *   - mongoose: Log model for logging.
 *   - winston: Logging to grok.log (version 3.17.0).
 *   - fileUtils.js: appendLog, errorLogPath.
 * Why Itâ€™s Here:
 *   - Modularizes test execution from testGenerator.js for Sprint 2 maintainability (05/XX/2025).
 * Change Log:
 *   - 05/XX/2025: Created to extract test execution logic from testGenerator.js.
 *     - Why: Improve modularity and reduce testGenerator.js complexity (User, 05/XX/2025).
 *     - How: Moved runTests logic from testGenerator.js, added validation and logging.
 *     - Test: Run POST /grok/test with { taskId, manual: true }, verify browser opens, blue log in LiveFeed.jsx.
 * Test Instructions:
 *   - Run `npm start`, POST /grok/edit with "Build CRM system": Confirm headless test runs, testResults in idurar_db.tasks.
 *   - POST /grok/test with { taskId, manual: true }: Verify browser opens, blue log in LiveFeed.jsx.
 *   - Check idurar_db.logs: Confirm test execution logs, no errors.
 * Future Enhancements:
 *   - Add parallel test execution (Sprint 4).
 *   - Support test result aggregation (Sprint 6).
 * Self-Notes:
 *   - Nate: Created to modularize test execution for Sprint 2 (05/XX/2025).
 * Rollback Instructions:
 *   - If tests fail: Remove testExecutionUtils.js, revert testGenerator.js to include runTests logic.
 *   - Verify /grok/test works after rollback.
 */
const winston = require('winston');
const path = require('path');
const mongoose = require('mongoose');
const { executeTests } = require('./taskTesterV18');
const { appendLog, errorLogPath } = require('./fileUtils');
const { getModel } = require('../db');
const { logInfo, logError } = require('./logUtils');

const logger = winston.createLogger({
  level: 'debug',
  format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
  transports: [
    new winston.transports.File({ filename: path.join(__dirname, '../../../grok.log'), maxsize: 1024 * 1024 * 10 }),
    new winston.transports.Console(),
  ],
});

async function runTests(testFile, stagedFiles, taskId, manual = false) {
  console.log('testExecutionUtils: runTests called with taskId:', taskId, 'manual:', manual, 'testFile:', testFile);
  const Log = await getModel('Log');

  if (!testFile || typeof testFile !== 'string') {
    await logError('Invalid test file path', 'testExecutionUtils', { taskId, testFile, timestamp: new Date().toISOString() });
    throw new Error('Invalid test file path');
  }

  try {
    await executeTests(testFile, stagedFiles, taskId, manual);
    const testResult = { success: true, testedFiles: stagedFiles.length, timestamp: new Date().toISOString() };
    await logInfo('Tests executed successfully', 'testExecutionUtils', {
      taskId,
      testFile,
      mode: manual ? 'manual' : 'auto',
      testedFiles: stagedFiles.length,
      timestamp: new Date().toISOString(),
    });
    return testResult;
  } catch (err) {
    await logError(`Test execution failed: ${err.message}`, 'testExecutionUtils', {
      taskId,
      stack: err.stack,
      timestamp: new Date().toISOString(),
    });
    await appendLog(errorLogPath, `# Test Execution Error\nTask ID: ${taskId}\nDescription: ${err.message}\nStack: ${err.stack}`);
    throw err;
  }
}

module.exports = { runTests };
