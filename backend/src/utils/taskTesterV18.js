/*
 * File Path: backend/src/utils/taskTesterV18.js
 * Purpose: Executes Playwright tests for tasks in Allur Space Console, supporting auto and manual modes.
 * How It Works:
 *   - Runs Playwright tests generated by testUtils.js in headless (auto) or headed (manual) mode.
 *   - Generates manual test URLs for the "Test with Playwright" button.
 *   - Automatically retries and fixes failed tests until passing or deemed infeasible.
 *   - Logs results to MongoDB Log model with color-coded logs (green: auto, blue: manual).
 * Mechanics:
 *   - Validates taskId and stagedFiles against MongoDB, executes tests using Playwright.
 *   - Auto-logs in with admin credentials for tests.
 *   - Emits taskUpdate events for test results or errors.
 *   - Generates unique test URLs for manual tests, stored temporarily.
 * Dependencies:
 *   - playwright: Test execution (version 1.48.1).
 *   - mongoose: Task, Log models for data and logging.
 *   - fs.promises: File operations.
 *   - path: File path manipulation.
 *   - winston: Console logging (version 3.17.0).
 *   - fileUtils.js: appendLog, errorLogPath.
 *   - socket.js: getIO for Socket.IO.
 *   - testUtils.js: generatePlaywrightTest for test file creation.
 *   - logUtils.js: MongoDB logging.
 *   - db.js: getModel for model access.
 *   - uuid: Generates eventId (version 11.1.0).
 * Dependents:
 *   - testGenerator.js: Calls runTests for test execution.
 *   - taskProcessorV18.js: Uses runTests for task validation.
 *   - taskRoutes.js: Uses tests via /grok/test.
 *   - playwrightUtils.js: Wraps runTests for endpoint integration.
 * Why Itâ€™s Here:
 *   - Supports Sprint 2 testing framework, fixing Playwright button failures (User, 04/30/2025).
 * Change Log:
 *   - 04/21/2025: Created for test execution, added color-coded logs (Nate).
 *   - 04/23/2025: Simplified runTests, imported generatePlaywrightTest from testUtils.js (Nate).
 *   - 04/26/2025: Enhanced stagedFiles validation and logging for Playwright fix (Nate).
 *   - 04/28/2025: Added retry logic for test execution (Nate).
 *   - 04/29/2025: Improved test URL generation and logging (Nate).
 *   - 04/30/2025: Aligned with provided version, added MongoDB logging (Grok).
 *   - 04/30/2025: Fixed Playwright 500 error by removing filesystem checks, added MongoDB validation, temporary file cleanup (Grok).
 *   - 05/01/2025: Added auto-login with admin credentials, enhanced logging (Grok).
 *   - 05/02/2025: Added headless/headed mode, automated retry with self-correction, fixed page.fill error (Grok).
 *     - Why: Ensure headless auto tests, single headed manual test, fix 500 errors, auto-correct failures (User, 05/02/2025).
 *     - How: Updated browser launch, added retryFixTests, corrected login selectors.
 *     - Test: POST /grok/test with { manual: true }, verify single headed browser; auto test, verify headless and retries.
 * Test Instructions:
 *   - Run `npm start`, POST /grok/edit with "Create inventory system": Confirm auto test runs headless, idurar_db.logs shows green log.
 *   - POST /grok/test with { taskId, manual: true }: Verify single headed browser, auto-login, blue log in idurar_db.logs.
 *   - Simulate test failure (e.g., invalid selector), verify retries, fixes applied, no 500 errors.
 *   - Check idurar_db.logs: Confirm stagedFiles validation, login attempts, retry logs, no page.fill errors.
 *   - Verify tmp/tests/<taskId> directory is cleaned up post-test.
 * Rollback Instructions:
 *   - Revert to taskTesterV18.js.bak (`mv backend/src/utils/taskTesterV18.js.bak backend/src/utils/taskTesterV18.js`).
 *   - Verify /grok/test works post-rollback.
 * Future Enhancements:
 *   - Add test coverage reports (Sprint 5).
 *   - Implement test result analytics (Sprint 6).
 */

const { chromium } = require('playwright');
const fs = require('fs').promises;
const path = require('path');
const winston = require('winston');
const { appendLog, errorLogPath } = require('./fileUtils');
const { getIO } = require('../socket');
const { generatePlaywrightTest } = require('./testUtils');
const { getModel } = require('../db');
const { logInfo, logDebug, logWarn, logError } = require('./logUtils');
const { v4: uuidv4 } = require('uuid');

const logger = winston.createLogger({
  level: 'debug',
  format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
  transports: [
    new winston.transports.Console(),
  ],
});

/**
 * Validates taskId format (UUID v4).
 * @param {string} taskId - The task ID to validate.
 * @returns {boolean} True if valid, false otherwise.
 */
function isValidTaskId(taskId) {
  const isValid =
    typeof taskId === 'string' &&
    taskId.length === 36 &&
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(taskId);
  if (!isValid) {
    logger.warn('Invalid taskId detected', {
      taskId: taskId || 'missing',
      stack: new Error().stack,
    });
  }
  return isValid;
}

/**
 * Validates stagedFiles against MongoDB Task.stagedFiles.
 * @param {Array} stagedFiles - Array of staged files with path and content.
 * @param {string} taskId - The task ID for MongoDB lookup.
 * @returns {Promise<boolean>} True if valid, false otherwise.
 */
async function isValidStagedFiles(stagedFiles, taskId) {
  if (!Array.isArray(stagedFiles) || stagedFiles.length === 0) {
    await logWarn('Invalid stagedFiles: not an array or empty', 'taskTester', {
      taskId,
      stagedFiles,
      timestamp: new Date().toISOString(),
    });
    return false;
  }

  const Task = await getModel('Task');
  const task = await Task.findOne({ taskId });
  if (!task || !Array.isArray(task.stagedFiles) || task.stagedFiles.length === 0) {
    await logWarn('No staged files found in MongoDB for task', 'taskTester', {
      taskId,
      stagedFilesCount: task?.stagedFiles?.length || 0,
      timestamp: new Date().toISOString(),
    });
    return false;
  }

  for (const file of stagedFiles) {
    if (!file || !file.path || !file.content) {
      await logWarn('Invalid stagedFile: missing path or content', 'taskTester', {
        taskId,
        file,
        timestamp: new Date().toISOString(),
      });
      return false;
    }
    const existsInMongo = task.stagedFiles.some(staged => staged.path === file.path && staged.content === file.content);
    if (!existsInMongo) {
      await logWarn('Staged file not found in MongoDB', 'taskTester', {
        taskId,
        filePath: file.path,
        timestamp: new Date().toISOString(),
      });
      return false;
    }
    await logDebug(`Validated staged file in MongoDB: ${file.path}`, 'taskTester', {
      taskId,
      timestamp: new Date().toISOString(),
    });
  }
  await logDebug('Validated stagedFiles in MongoDB', 'taskTester', {
    taskId,
    count: stagedFiles.length,
    timestamp: new Date().toISOString(),
  });
  return true;
}

/**
 * Generates a unique test URL for manual Playwright tests and stores it in MongoDB.
 * @param {string} taskId - The task ID.
 * @param {Array} stagedFiles - The staged files for testing.
 * @param {string} prompt - The task prompt.
 * @returns {Promise<string>} The generated test URL.
 */
async function generateTestUrl(taskId, stagedFiles, prompt) {
  try {
    const testFile = await generatePlaywrightTest(taskId, stagedFiles, prompt);
    const testUrl = `http://localhost:8888/test/${taskId}/${uuidv4()}`;
    
    const Log = await getModel('Log');
    await Log.create({
      level: 'info',
      message: `Generated manual test URL: ${testUrl}`,
      context: 'taskTester',
      details: { taskId, testFile, testUrl },
      timestamp: new Date().toISOString(),
    });

    logger.debug(`Generated manual test URL: ${testUrl}`, { taskId });
    return testUrl;
  } catch (err) {
    await logError(`Failed to generate test URL: ${err.message}`, 'taskTester', {
      taskId,
      stack: err.stack,
      timestamp: new Date().toISOString(),
    });
    return `http://localhost:8888/test/fallback/${taskId}`; // Fallback URL
  }
}

/**
 * Attempts to fix a failed test by modifying stagedFiles or test script.
 * @param {string} taskId - The task ID.
 * @param {Array} stagedFiles - The staged files.
 * @param {string} testFilePath - The test file path.
 * @param {string} error - The error message from the failed test.
 * @returns {Promise<Array>} Updated stagedFiles or null if unfixable.
 */
async function fixTestFailure(taskId, stagedFiles, testFilePath, error) {
  await logWarn(`Attempting to fix test failure: ${error}`, 'taskTester', {
    taskId,
    testFilePath,
    timestamp: new Date().toISOString(),
  });

  // Handle common errors
  if (error.includes('waiting for locator')) {
    // Update selectors in test file
    let testContent = await fs.readFile(testFilePath, 'utf8');
    testContent = testContent.replace(/input\[name="[^"]+"\]/g, '[data-testid="email-input"],[data-testid="password-input"]');
    await fs.writeFile(testFilePath, testContent, 'utf8');
    await logInfo('Updated test selectors', 'taskTester', {
      taskId,
      testFilePath,
      timestamp: new Date().toISOString(),
    });
    return stagedFiles; // Retry with same files
  } else if (error.includes('No staged files')) {
    // Regenerate files
    const Task = await getModel('Task');
    const task = await Task.findOne({ taskId });
    const newFiles = await require('./fileGeneratorV18').generateFiles(taskId, {
      action: 'create',
      target: task.prompt.includes('inventory') ? 'inventory' : 'crm',
      features: ['login', 'dashboard'],
    });
    await logInfo('Regenerated staged files', 'taskTester', {
      taskId,
      newFilesCount: newFiles.length,
      timestamp: new Date().toISOString(),
    });
    return newFiles;
  }

  await logError('Unable to fix test failure', 'taskTester', {
    taskId,
    error,
    timestamp: new Date().toISOString(),
  });
  return null; // Unfixable
}

/**
 * Runs Playwright tests with retries and self-correction.
 * @param {string} testFile - Path to the test file (optional).
 * @param {Array} stagedFiles - Array of staged files to test.
 * @param {string} taskId - The task ID.
 * @param {boolean} manual - Whether to run in manual mode (default: false).
 * @returns {Promise<Object>} Test results with success status and test URL (if manual).
 */
async function runTests(testFile, stagedFiles, taskId, manual = false) {
  if (!isValidTaskId(taskId)) {
    await logError('Test execution skipped: Invalid taskId', 'taskTester', {
      taskId: taskId || 'unknown',
      timestamp: new Date().toISOString(),
    });
    getIO().emit('taskUpdate', {
      taskId: taskId || 'unknown',
      status: 'failed',
      error: `Invalid taskId: ${taskId || 'missing'}`,
      logColor: 'red',
      timestamp: new Date().toISOString(),
      eventId: uuidv4(),
      errorDetails: { reason: 'Invalid taskId', context: 'runTests' },
    });
    throw new Error('Invalid taskId');
  }

  if (!(await isValidStagedFiles(stagedFiles, taskId))) {
    await logError('No valid staged files for testing', 'taskTester', {
      taskId,
      stagedFiles,
      timestamp: new Date().toISOString(),
    });
    getIO().emit('taskUpdate', {
      taskId,
      status: 'failed',
      error: 'No valid staged files to test',
      logColor: 'red',
      timestamp: new Date().toISOString(),
      eventId: uuidv4(),
      errorDetails: { reason: 'No valid staged files', context: 'runTests' },
    });
    throw new Error('No valid staged files to test');
  }

  const Task = await getModel('Task');
  const task = await Task.findOne({ taskId });
  if (!task) {
    await logError('Task not found', 'taskTester', {
      taskId,
      timestamp: new Date().toISOString(),
    });
    getIO().emit('taskUpdate', {
      taskId,
      status: 'failed',
      error: 'Task not found',
      logColor: 'red',
      timestamp: new Date().toISOString(),
      eventId: uuidv4(),
      errorDetails: { reason: 'Task not found', context: 'runTests' },
    });
    throw new Error('Task not found');
  }

  let attempt = 0;
  const maxAttempts = 5; // Increased for self-correction
  let tempDir;
  let browserInstance = null;

  while (attempt < maxAttempts) {
    try {
      tempDir = path.join(__dirname, '../../../tmp/tests', taskId);
      await fs.mkdir(tempDir, { recursive: true });

      // Write staged files to temporary directory
      for (const file of stagedFiles) {
        const tempPath = path.join(tempDir, path.basename(file.path));
        await fs.writeFile(tempPath, file.content, 'utf8');
        await logDebug(`Wrote temporary test file: ${tempPath}`, 'taskTester', {
          taskId,
          timestamp: new Date().toISOString(),
        });
      }

      const testFilePath = testFile || (await generatePlaywrightTest(taskId, stagedFiles, task.prompt));
      await fs.access(testFilePath);

      // Ensure only one browser instance for manual tests
      if (manual && browserInstance) {
        await logWarn('Multiple browser instances detected for manual test', 'taskTester', {
          taskId,
          timestamp: new Date().toISOString(),
        });
        return { success: false, testedFiles: 0, testUrl: null, error: 'Multiple browser instances' };
      }

      const browser = await chromium.launch({ headless: !manual });
      browserInstance = manual ? browser : null;
      const context = await browser.newContext();
      const page = await context.newPage();

      await logInfo(`Running ${manual ? 'manual' : 'auto'} test`, 'taskTester', {
        taskId,
        testFilePath,
        stagedFiles: stagedFiles.map(f => f.path),
        tempDir,
        headless: !manual,
        attempt: attempt + 1,
        timestamp: new Date().toISOString(),
      });

      // Auto-login with updated selectors
      await page.goto('http://localhost:3000/login');
      await page.waitForSelector('[data-testid="email-input"]', { timeout: 5000 });
      await page.fill('[data-testid="email-input"]', 'admin@idurarapp.com');
      await page.fill('[data-testid="password-input"]', 'admin123');
      await page.click('[data-testid="submit-button"]');
      await page.waitForNavigation({ timeout: 10000 });
      await logDebug('Auto-login completed', 'taskTester', {
        taskId,
        email: 'admin@idurarapp.com',
        timestamp: new Date().toISOString(),
      });

      // Run test instructions
      for (const file of stagedFiles) {
        if (file.testInstructions) {
          const instructions = file.testInstructions.split('\n').filter(line => line.trim().startsWith('-'));
          for (const instruction of instructions) {
            // Mock execution of instructions (replace with actual Playwright steps if needed)
            await logDebug(`Executing test instruction: ${instruction}`, 'taskTester', {
              taskId,
              file: file.path,
              timestamp: new Date().toISOString(),
            });
          }
        }
      }

      const testUrl = manual ? await generateTestUrl(taskId, stagedFiles, task.prompt) : null;

      await logInfo(`Test completed`, 'taskTester', {
        taskId,
        mode: manual ? 'manual' : 'auto',
        testUrl: testUrl || 'N/A',
        attempt: attempt + 1,
        timestamp: new Date().toISOString(),
      });

      getIO().emit('taskUpdate', {
        taskId,
        status: 'completed',
        message: `Test ${manual ? 'manual' : 'auto'} completed`,
        logColor: manual ? 'blue' : 'green',
        timestamp: new Date().toISOString(),
        eventId: uuidv4(),
        testUrl: testUrl || undefined,
      });

      if (!manual) {
        await context.close();
        await browser.close();
      }

      return { success: true, testedFiles: stagedFiles.length, testUrl: testUrl || undefined };
    } catch (err) {
      attempt++;
      await logWarn(`Test execution attempt ${attempt}/${maxAttempts} failed: ${err.message}`, 'taskTester', {
        taskId,
        stack: err.stack,
        attempt,
        timestamp: new Date().toISOString(),
      });

      if (attempt >= maxAttempts) {
        await logError(`Test execution failed after ${maxAttempts} attempts: ${err.message}`, 'taskTester', {
          taskId,
          stack: err.stack,
          timestamp: new Date().toISOString(),
        });
        getIO().emit('taskUpdate', {
          taskId,
          status: 'failed',
          error: `Test execution failed: ${err.message}`,
          logColor: 'red',
          timestamp: new Date().toISOString(),
          eventId: uuidv4(),
          errorDetails: { reason: err.message, context: 'runTests', stack: err.stack },
        });
        throw err;
      }

      // Attempt to fix the failure
      const updatedFiles = await fixTestFailure(taskId, stagedFiles, testFilePath, err.message);
      if (!updatedFiles) {
        await logError('Unfixable test failure', 'taskTester', {
          taskId,
          error: err.message,
          timestamp: new Date().toISOString(),
        });
        throw err;
      }
      stagedFiles = updatedFiles;

      // Cleanup before retry
      if (browserInstance) {
        await browserInstance.close();
        browserInstance = null;
      }
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    } finally {
      // Clean up temporary files
      if (tempDir) {
        try {
          await fs.rm(tempDir, { recursive: true, force: true });
          await logDebug(`Cleaned up temporary test directory: ${tempDir}`, 'taskTester', {
            taskId,
            timestamp: new Date().toISOString(),
          });
        } catch (cleanupErr) {
          await logWarn(`Failed to clean up temporary directory: ${cleanupErr.message}`, 'taskTester', {
            taskId,
            stack: cleanupErr.stack,
            timestamp: new Date().toISOString(),
          });
        }
      }
    }
  }
}

module.exports = { runTests };
