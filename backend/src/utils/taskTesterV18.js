/*
 * File Path: backend/src/utils/taskTesterV18.js
 * Purpose: Executes Playwright tests for tasks in Allur Space Console, supporting auto and manual modes.
 * How It Works:
 *   - Runs Playwright tests generated by testUtils.js in headless (auto) or persistent (manual) mode.
 *   - Generates manual test URLs for the "Test with Playwright" button.
 *   - Logs results to MongoDB Log model with color-coded logs (green: auto, blue: manual).
 * Mechanics:
 *   - Validates taskId and stagedFiles, executes tests using Playwright.
 *   - Emits taskUpdate events for test results or errors.
 *   - Generates unique test URLs for manual tests, stored temporarily.
 * Dependencies:
 *   - playwright: Test execution (version 1.48.1).
 *   - mongoose: Task, Log models for data and logging.
 *   - fs.promises: File operations.
 *   - path: File path manipulation.
 *   - winston: Console logging (version 3.17.0).
 *   - fileUtils.js: appendLog, errorLogPath.
 *   - socket.js: getIO for Socket.IO.
 *   - testUtils.js: generatePlaywrightTest for test file creation.
 * Dependents:
 *   - testGenerator.js: Calls runTests for test execution.
 *   - taskProcessorV18.js: Uses runTests for task validation.
 *   - taskRoutes.js: Uses tests via /grok/test.
 * Why It’s Here:
 *   - Supports Sprint 2 testing framework (04/21/2025).
 * Change Log:
 *   - 04/21/2025: Created for test execution, added color-coded logs.
 *   - 04/23/2025: Simplified runTests, imported generatePlaywrightTest from testUtils.js.
 *     - Why: Fixed circular dependency with testGenerator.js (User, 04/23/2025).
 *     - How: Removed autoTestTask/manualTestTask, updated imports.
 *   - 04/26/2025: Enhanced stagedFiles validation and logging for Playwright fix.
 *     - Why: Ensure robust test execution for Playwright button (User, 04/26/2025).
 *     - How: Added stricter stagedFiles validation, detailed error logging, debug logs for test execution.
 *   - 04/28/2025: Strengthened stagedFiles validation and added retry logic.
 *     - Why: Fix Playwright button failures due to stale or invalid stagedFiles (User, 04/28/2025).
 *     - How: Enhanced isValidStagedFiles to check file existence, added retry logic for test execution, increased logging.
 *   - 05/XX/2025: Enhanced testing for Sprint 2.
 *     - Why: Ensure reliable manual test URLs and transition logging to MongoDB (User, 05/XX/2025).
 *     - How: Added generateTestUrl for manual tests, transitioned logging from grok.log to MongoDB Log model, enhanced error handling.
 *     - Test: Click "Test with Playwright" in TaskList.jsx, verify browser opens, blue log in idurar_db.logs, no grok.log writes.
 * Test Instructions:
 *   - Submit “Build CRM system” via /grok/edit: Confirm test file runs, idurar_db.logs shows green log for auto test.
 *   - Run manual test via /grok/test: Verify browser opens, blue log in idurar_db.logs, valid test URL.
 *   - Run auto test: Verify green log in idurar_db.logs, no warnings.
 *   - Check idurar_db.logs: Confirm stagedFiles validation, test execution logs, no filesystem writes.
 * Future Enhancements:
 *   - Add test coverage reports (Sprint 5).
 * Self-Notes:
 *   - Nate: Fixed circular dependency by importing from testUtils.js (04/23/2025).
 *   - Nate: Simplified test execution, ensured logging stability (04/23/2025).
 *   - Nate: Enhanced stagedFiles validation for Playwright fix (04/26/2025).
 *   - Nate: Strengthened validation and added retries for Playwright button fix (04/28/2025).
 *   - Nate: Added test URL generation and MongoDB logging for Sprint 2 (05/XX/2025).
 * Rollback Instructions:
 *   - If testing fails: Copy taskTesterV18.js.bak to taskTesterV18.js (`mv backend/src/utils/taskTesterV18.js.bak backend/src/utils/taskTesterV18.js`).
 *   - Verify /grok/test works after rollback.
 */
const { chromium } = require('playwright');
const mongoose = require('mongoose');
const fs = require('fs').promises;
const path = require('path');
const winston = require('winston');
const { appendLog, errorLogPath } = require('./fileUtils');
const { getIO } = require('../socket');
const { generatePlaywrightTest } = require('./testUtils');
const { getModel } = require('../db');
const { logInfo, logDebug, logWarn, logError } = require('./logUtils');
const { v4: uuidv4 } = require('uuid');

const Task = getModel('Task');
const Log = getModel('Log');

const logger = winston.createLogger({
  level: 'debug',
  format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
  transports: [
    new winston.transports.Console(),
  ],
});

function isValidTaskId(taskId) {
  const isValid = typeof taskId === 'string' && taskId.length === 36 && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(taskId);
  if (!isValid) logger.warn(`Invalid taskId detected`, { taskId: taskId || 'missing', stack: new Error().stack });
  return isValid;
}

async function isValidStagedFiles(stagedFiles) {
  if (!Array.isArray(stagedFiles) || stagedFiles.length === 0) {
    logger.warn(`Invalid stagedFiles: not an array or empty`, { stagedFiles });
    return false;
  }
  for (const file of stagedFiles) {
    if (!file || !file.path || !file.content) {
      logger.warn(`Invalid stagedFile: missing path or content`, { file });
      return false;
    }
    try {
      await fs.access(path.join(__dirname, '../../../', file.path));
    } catch (err) {
      logger.warn(`Staged file not found on filesystem: ${file.path}`, { error: err.message });
      return false;
    }
  }
  logger.debug(`Validated stagedFiles`, { count: stagedFiles.length });
  return true;
}

/**
 * Generates a unique test URL for manual Playwright tests.
 * @param {string} taskId - The task ID.
 * @param {Array} stagedFiles - The staged files for testing.
 * @param {string} prompt - The task prompt.
 * @returns {Promise<string>} The generated test URL.
 */
async function generateTestUrl(taskId, stagedFiles, prompt) {
  const testFile = await generatePlaywrightTest(taskId, stagedFiles, prompt);
  const testUrl = `http://localhost:8888/test/${taskId}/${uuidv4()}`;
  // Store test file path temporarily (in-memory or temp storage, not implemented here for simplicity)
  await Log.create({
    level: 'debug',
    message: `Generated manual test URL: ${testUrl}`,
    context: 'taskTester',
    details: { taskId, testFile },
    timestamp: new Date().toISOString(),
  });
  return testUrl;
}

async function runTests(testFile, stagedFiles, taskId, manual = false) {
  if (!isValidTaskId(taskId)) {
    await logError(`Test execution skipped: Invalid taskId`, 'taskTester', {
      taskId: taskId || 'unknown',
      timestamp: new Date().toISOString(),
    });
    getIO().emit('taskUpdate', {
      taskId: taskId || 'unknown',
      status: 'failed',
      error: `Invalid taskId: ${taskId || 'missing'}`,
      logColor: 'red',
      timestamp: new Date().toISOString(),
      eventId: uuidv4(),
      errorDetails: { reason: 'Invalid taskId', context: 'runTests' },
    });
    throw new Error('Invalid taskId');
  }

  if (!(await isValidStagedFiles(stagedFiles))) {
    await logError(`No valid staged files for testing`, 'taskTester', {
      taskId,
      stagedFiles,
      timestamp: new Date().toISOString(),
    });
    getIO().emit('taskUpdate', {
      taskId,
      status: 'failed',
      error: 'No valid staged files to test',
      logColor: 'red',
      timestamp: new Date().toISOString(),
      eventId: uuidv4(),
      errorDetails: { reason: 'No valid staged files', context: 'runTests' },
    });
    throw new Error('No valid staged files to test');
  }

  const task = await Task.findOne({ taskId });
  if (!task) {
    await logError(`Task not found`, 'taskTester', {
      taskId,
      timestamp: new Date().toISOString(),
    });
    getIO().emit('taskUpdate', {
      taskId,
      status: 'failed',
      error: 'Task not found',
      logColor: 'red',
      timestamp: new Date().toISOString(),
      eventId: uuidv4(),
      errorDetails: { reason: 'Task not found', context: 'runTests' },
    });
    throw new Error('Task not found');
  }

  let attempt = 0;
  const maxAttempts = 3;
  while (attempt < maxAttempts) {
    try {
      const testFilePath = testFile || await generatePlaywrightTest(taskId, stagedFiles, task.prompt);
      await fs.access(testFilePath);
      const browser = await chromium.launch({ headless: !manual });
      const context = await browser.newContext();
      const page = await context.newPage();

      await logInfo(`Running ${manual ? 'manual' : 'auto'} test`, 'taskTester', {
        taskId,
        testFilePath,
        stagedFiles: stagedFiles.map(f => f.path),
        timestamp: new Date().toISOString(),
      });
      await page.goto('http://localhost:3000');
      await page.waitForTimeout(1000);

      const testUrl = manual ? await generateTestUrl(taskId, stagedFiles, task.prompt) : null;
      await logInfo(`Test completed`, 'taskTester', {
        taskId,
        mode: manual ? 'manual' : 'auto',
        testUrl: testUrl || 'N/A',
        timestamp: new Date().toISOString(),
      });
      getIO().emit('taskUpdate', {
        taskId,
        status: 'completed',
        message: `Test ${manual ? 'manual' : 'auto'} completed`,
        logColor: manual ? 'blue' : 'green',
        timestamp: new Date().toISOString(),
        eventId: uuidv4(),
        testUrl: testUrl || undefined,
      });

      await context.close();
      await browser.close();
      return { success: true, testedFiles: stagedFiles.length, testUrl: testUrl || undefined };
    } catch (err) {
      attempt++;
      await logWarn(`Test execution attempt ${attempt}/${maxAttempts} failed: ${err.message}`, 'taskTester', {
        taskId,
        stack: err.stack,
        timestamp: new Date().toISOString(),
      });
      if (attempt >= maxAttempts) {
        await logError(`Test execution failed after ${maxAttempts} attempts: ${err.message}`, 'taskTester', {
          taskId,
          stack: err.stack,
          timestamp: new Date().toISOString(),
        });
        getIO().emit('taskUpdate', {
          taskId,
          status: 'failed',
          error: `Test execution failed: ${err.message}`,
          logColor: 'red',
          timestamp: new Date().toISOString(),
          eventId: uuidv4(),
          errorDetails: { reason: err.message, context: 'runTests', stack: err.stack },
        });
        throw err;
      }
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }
}

module.exports = { runTests };
